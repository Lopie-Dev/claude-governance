import * as fs from 'fs';
import * as path from 'path';
import * as Handlebars from 'handlebars';
import { GovernanceConfig, ApprovalGate } from '../schema/governance';

export interface GeneratedHook {
  filename: string;
  content: string;
  executable: boolean;
}

export class HooksGenerator {
  private templatesDir: string;

  constructor(templatesDir?: string) {
    this.templatesDir = templatesDir || path.join(__dirname, '..', 'templates', 'hooks');
  }

  /**
   * Generate all hook scripts from governance config
   */
  generate(config: GovernanceConfig): GeneratedHook[] {
    const hooks: GeneratedHook[] = [];

    // Generate secret detection hook
    if (config.secrets?.detection?.patterns && config.secrets.detection.patterns.length > 0) {
      hooks.push(this.generateSecretDetectionHook(config));
    }

    // Generate custom hooks from approval gates
    if (config.approval_gates) {
      for (const gate of config.approval_gates) {
        if (gate.action.type === 'command' && gate.action.command?.includes('.claude/hooks/')) {
          // This gate references a custom hook script - generate it
          const customHook = this.generateCustomHook(gate, config);
          if (customHook) {
            hooks.push(customHook);
          }
        }
      }
    }

    return hooks;
  }

  /**
   * Generate secret detection hook
   */
  private generateSecretDetectionHook(config: GovernanceConfig): GeneratedHook {
    const templatePath = path.join(this.templatesDir, 'detect-secrets.sh.hbs');
    const template = fs.readFileSync(templatePath, 'utf8');
    const compiled = Handlebars.compile(template);

    const content = compiled({
      patterns: config.secrets?.detection?.patterns || [],
      enforcement: config.secrets?.enforcement || {},
    });

    return {
      filename: 'detect-secrets.sh',
      content,
      executable: true,
    };
  }

  /**
   * Generate custom hook for approval gate
   */
  private generateCustomHook(gate: ApprovalGate, config: GovernanceConfig): GeneratedHook | null {
    // Extract filename from command
    const command = gate.action.command;
    if (!command) return null;

    const match = command.match(/\.claude\/hooks\/([^"]+\.sh)/);
    if (!match) return null;

    const filename = match[1];

    // Generate hook based on gate configuration
    let content = '#!/bin/bash\n';
    content += `# Auto-generated by claude-governance\n`;
    content += `# ${gate.name}\n\n`;
    content += 'INPUT=$(cat)\n\n';

    // Add gate-specific logic
    if (gate.trigger.command_pattern) {
      content += `COMMAND=$(echo "$INPUT" | jq -r '.tool_input.command')\n\n`;
      content += `# Check if command matches pattern\n`;
      content += `if ! echo "$COMMAND" | grep -qE '${gate.trigger.command_pattern}'; then\n`;
      content += `  exit 0\n`;
      content += `fi\n\n`;
    }

    if (gate.trigger.path_pattern) {
      content += `FILE_PATH=$(echo "$INPUT" | jq -r '.tool_input.file_path // .tool_input.path')\n\n`;
      content += `# Check if file matches pattern\n`;
      content += `if ! echo "$FILE_PATH" | grep -qE '${gate.trigger.path_pattern}'; then\n`;
      content += `  exit 0\n`;
      content += `fi\n\n`;
    }

    // Add blocking logic
    content += `# Gate logic\n`;
    content += `cat >&2 <<EOF\n`;
    content += `⚠️  ${gate.name}\n\n`;
    if (gate.action.prompt) {
      content += `${gate.action.prompt}\n`;
    }
    content += `EOF\n\n`;

    // Default: block for manual review
    content += `# Exit 2 to block, exit 0 to allow\n`;
    content += `exit 0\n`;

    return {
      filename,
      content,
      executable: true,
    };
  }
}
